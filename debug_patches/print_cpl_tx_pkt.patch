diff -r 93f66f2d6255 dev/T4/linux/iw_cxgb4/cm.c
--- a/dev/T4/linux/iw_cxgb4/cm.c	Mon Aug 02 16:55:56 2021 +0530
+++ b/dev/T4/linux/iw_cxgb4/cm.c	Tue Aug 03 22:48:32 2021 +0530
@@ -4275,10 +4275,6 @@ static int rx_pkt(struct chrd_dev *dev, 
 	unsigned int chip_ver = CHELSIO_CHIP_VERSION(dev->rdev.lldi.adapter_type);
 
 	pr_err("Demo: %s()-%d\n", __func__, __LINE__);
-	/* Drop all non-SYN packets */
-	if (!(cpl->l2info & cpu_to_be32(F_RXF_SYN)))
-		goto reject;
-
 	/* 
 	 * Drop all packets which did not hit the filter.
 	 * Unlikely to happen.
@@ -4286,17 +4282,6 @@ static int rx_pkt(struct chrd_dev *dev, 
 	if (!(rss->filter_hit && rss->filter_tid))
 		goto reject;
 
-	/* 
-	 * Calculate the server tid from filter hit index from cpl_rx_pkt.
-	 */
-	stid = cpu_to_be32(rss->hash_val);
-
-	lep = (struct chrd_ep *)get_ep_from_stid(dev, stid);
-	if (!lep) {
-		pr_debug("connect request on invalid stid %d\n", stid);
-		goto reject;
-	}
-
 	switch (chip_ver) {
 	case CHELSIO_T4:
 		eth_hdr_len = G_RX_ETHHDR_LEN(htonl(cpl->l2info));
@@ -4311,6 +4296,7 @@ static int rx_pkt(struct chrd_dev *dev, 
 		break;
 	}
 
+	pr_err("Demo: %s()-%d\n", __func__, __LINE__);
 	if (eth_hdr_len == ETH_HLEN) {
 		eh = (struct ethhdr *)(req + 1);
 		iph = (struct iphdr *)(eh + 1);
@@ -4320,6 +4306,60 @@ static int rx_pkt(struct chrd_dev *dev, 
 		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), ntohs(cpl->vlan));
 	}
 
+	pr_err("Demo: %s()-%d pkt protocol %d\n", __func__, __LINE__, iph->protocol);
+	/* Could be a ROCEv2 CM packet, process it accordingly */
+	if (iph->protocol == IPPROTO_UDP) {
+		/* Add the received packet to local queue and invoke cq notifier.
+		  When polled, poll cq will eventually frame a CQE and return it
+		  to the RDMA stack */
+		pr_err("Demo: %s()-%d UDP pkt processing begin!\n", __func__, __LINE__);
+
+		pr_err("Demo: %s()-%d RX_PKT() skb DUMP\n", __func__, __LINE__);
+
+		if (!skb_linearize(skb)) {
+			unsigned int i, j, k;
+			unsigned char *skb_data = (void *)(rss+1);
+			pr_err("Hex dump skb_data %llx, skb->data %llx, rss %llx, skb->len %u, rss hdr size %zu\n",
+				(unsigned long long)skb_data, (unsigned long long)skb->data, (unsigned long long)rss, skb->len, sizeof(struct rss_header));
+			j = ((skb->len - sizeof(struct rss_header)) / 16);
+			for (i = 0; i < j; i++) {
+				pr_err("%04x: %02x %02x %02x %02x %02x %02x %02x %02x  %02x %02x %02x %02x %02x %02x %02x %02x\n", i*16,
+			        	skb_data[0], skb_data[1], skb_data[2], skb_data[3], skb_data[4], skb_data[5],
+					skb_data[6], skb_data[7], skb_data[8], skb_data[9], skb_data[10], skb_data[11],
+					skb_data[12], skb_data[13], skb_data[14], skb_data[15]);
+				skb_data += 16;
+				if (i == (j - 1)) {
+					pr_err("%04x: ", i*16);
+					for (k = 0; k < ((skb->len - sizeof(struct rss_header)) % 16); k++) {
+						printk(KERN_CONT "%02x ", skb_data[k]);
+						if (k == 7)
+							printk(KERN_CONT " ");
+					}
+					pr_err("Bhar: skb_data %llx mod %d\n", (unsigned long long)skb_data, (skb->len - sizeof(struct rss_header)) % 16);
+				}
+        		}
+
+		} else {
+			pr_err("skb_linearize failed\n");
+		}
+
+		return 0;
+	}
+	/* Drop all non-SYN packets */
+	if (!(cpl->l2info & cpu_to_be32(F_RXF_SYN)))
+		goto reject;
+
+	/*
+	 * Calculate the server tid from filter hit index from cpl_rx_pkt.
+	 */
+	stid = cpu_to_be32(rss->hash_val);
+
+	lep = (struct chrd_ep *)get_ep_from_stid(dev, stid);
+	if (!lep) {
+		pr_debug("connect request on invalid stid %d\n", stid);
+		goto reject;
+	}
+
 	if (iph->version != 0x4)
 		goto reject;
 
